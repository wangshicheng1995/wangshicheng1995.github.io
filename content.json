{"pages":[],"posts":[{"title":"Https 原理解析","text":"写在前面 Https 加密原理 传统的 HTTP 传输方式 对称加密 非对称加密 非对称加密 &amp; 对称加密 中间人攻击 CA机构 写在前面# https 加密原理原创内容为 B 站 up 主 free-coder 制作，本文只是对视频内容进行整理并总结为学习笔记。 原视频地址及在撰写此文时查阅的一些资料地址一并放在本文最后，方便读者朔源。 free-coder 的编程类视频科普逻辑清晰且有深度，向他学习。 Https 加密原理#首先放结论，HTTPS 使用了非对称加密+对称加密+CA机构认证三种技术来保证了交互过程中的安全性。 接下来来分析这三种技术是什么，以及为什么要这么使用。 传统的 HTTP 传输方式#传统的 HTTP 传输过程中客户端（Client）到服务端（Server）之间的数据传输是 明文 的方式，也就是说没有保密性可言，黑客一但从中干预，我们的数据就会泄露。 HTTP 传输缺点：明文传输，无安全性。 对称加密#假设我们有一个算法 f ，它有两个参数，一个为常量 k，即秘钥；一个为变量，可能是传输的数据 data ，也可能是密文 x。根据上述条件，我们可以得出两个公式： f(k, data) = x f(k, x) = data 即： 通过算法 f ,根据秘钥 k，我们可以将数据加密为密文 x； 通过算法 f ,根据秘钥 k, 我们可以将密文 x 解密为数据 data； 了解了以上内容，我们来看加密对称。因为有了算法 f，因此在客户端向服务端发送请求的数据不再是直接传输明文 data，而是传输经过秘钥 k 加密的密文 x；服务端向客户端也是传输 x，客户端在接受到 x 后进行通过秘钥 k 解密得到 data。 通过这种方式进行传输，看上去每次传输了加密的密文，黑客只能拿到密文而无法拿到真实的数据。其实事实上并不是如此，问题在哪呢？问题在 服务端给客户端制定秘钥 k 时，一是不知道有多少个客户端需要秘钥，二是现实中不可能给每个客户端都生成一个 k。 假设有有一亿个客户端，服务端将要存一亿个 k, k 的存储甚至要比整个业务处理的数据还要大。因此对称加密下，服务端一般只会生成一个 k，被称为公共 k，也就是我们常说的公钥。既然是公钥黑客当然也能拿到，这样的话加密就失去了意义。 对称加密缺点：公钥 k 可以被黑客获取，依然无安全性。 非对称加密#在非对称加密中，我们依然有一个算法 f，但此时将不在是只有一个秘钥 k，而是将 k 一分为二，一个为公钥 pk，一个为私钥sk。基于此条件，可以得到四个新公式： f(pk, data) = x f(sk, x) = data f(sk, data) = x f(pk, x) = data 即： 通过公钥 pk 加密的密文，可以用私钥 sk 进行解密； 通过私钥 sk 加密的密文，可以用 pk 进行解密； 客户端向服务端索要公钥 pk（服务端同时拥有公钥和私钥），客户端将公钥 pk 传给客户端，客户端拿到 pk； 客户端使用公钥将传输的数据 data 加密为密文 x，传输给服务端； 服务端使用私钥 sk 将密文解密为 data。 非对称加密解决了对称加密中 pk 泄露的问题，黑客即使从中截获到了 x，因为没有 sk，因此也是无法破解密文的。 但是在非对称加密中，我们看到客户端向服务端发送数据是没问题的，但是服务端向客户端发送数据呢？ 如果服务端使用私钥 sk 对数据进行加密发送给客户端，黑客就能使用 pk 进行解密了。 在对称加密中我们提到过，公钥是所有人都可以拿到的。 非对称加密缺点：只能实现客户端对服务端发送数据的加密。 目前来看，非对称加密能解决 k 的问题，但是只能单方面传输；对称加密可以实现双向传输，但是无法解决 k 问题。 如何解决这个问题呢？ HTTPS 的解决方案是使用对称加密与非对称加密混合的方式。先利用非对称加密的方式在服务端和客户端之间达成一个协商，指定一个零时的 k，然后再利用对称加密进行数据的交互。 非对称加密 &amp; 对称加密# 首先，开始还是和非对称加密一样，客户端向服务器索要公钥 pk，服务器将 pk 返回给客户端。紧接着，客户端将 data（这里的 data 可以是真实传输的数据也可以是随机的一个数）加密为密文 x 传输给服务端，服务端用 sk 进行解密。 在解密之后，服务端将会使用此次传输的 data 作为今后传输的 k，并返回给客户端一个回应，代表的意思是“OK，收到了我们协商的 k”。 在后面就是按照对称加密一样进行数据传输了。 这种方式的好处是：因为每个客户端和服务端约定的 k 都不一样，即使在传输中黑客截获了请求，但是由于不知道真正的 k 值，也就无法进行破解。 这种混合加密的方式目前来说已经是相当安全的一种加密方式了。 中间人攻击#然而这种看起来几乎无懈可击的加密方式就真的没有问题了吗？黑客会不会比我们更技高一筹？我们来看看下面这种情况。 我们假设，在一开始客户端向服务端索要公钥的时候 ，黑客就已经介入了。它也有一个pk 和 sk，为了区分，我们叫它 pk1 和 sk1。这样会变成这样一个过程： 服务端向客户端索要 pk，黑客拦截了服务端的请求，将假的 pk，即黑客的 pk1 返回给客户端； 黑客假装自己是客户端，也向服务端请求索要公钥 pk，并拿到真的 ‘pk’； 客户端拿到假的 pk，并使用它将 data 加密为 x1 发送给客户端； 黑客继续拦截请求，拿到 x1 后加装自己是服务端给客户端发送一个 ok，代表协商完成，同意使用传输的 data 作为今后的 k； 黑客将服务端传给自己的 data 发送给服务端，同样地，跟真正的服务端建立起信任，开始使用 data 作为 k； 至此（途中灰色双箭头处），黑客充当中间人在客户端与服务端之间双向建立了信任，它让客户端以为自己一直在跟服务端沟通，让服务端以为自己一直在跟客户端进行沟通。其实是黑客在中间做一个转发的作用。 接下来的事情大家都知道了，服务端将真正的 data 传给黑客，黑客再传给服务端。在这个过程中，黑客完全拿到了我们的真实数据，并在适当的时候窃取我们的隐私，卷走我们的钱财。 非对称加密与对称加密的缺陷：中间人攻击问题。 CA机构#这个问题解决的方式也很简单，目前的解决方案是引入一个 CA（Certificate Authority） 即 CA认证机构，因为中间人攻击最大的问题在于黑客一开始的介入让客户端不知道自己拿到的 pk 是否是真实的 pk。引入 CA 后，所有的 pk 都是由机构发放，客户端只认 CA 的pk，其它的 pk 都不认可，这样就可以了。 简单看一下引入 CA 后的传输情况： CA 机构自己也有一个 pk 和 sk，方便区分我们叫 cpk 和 csk。 因为要防止 pk 被黑客获取，这里不再直接传输 pk。pk 先由 csk 进行加密，加密成 license； 客户端向服务端请求 license，拿到 license； 客户端不再向 CA 获取 cpk，因为在获取的过程中同样可能会被黑客拦截，而是用写死在客户端的内置证书链拿到 cpk，对 license 进行解密，拿到真正的 pk； 开始安全传输过程。 这样黑客就无法充当中间人介入到获取证书的过程中。因为一旦介入，客户端获取到的 license 就是没有经过认证的。当内置的 cpk 无法解析 license 时，浏览器就会弹出红色的，来警告提示你证书不安全。 一般来说，CA license 的下发是需要付费的。毕竟 CA 维护了大量的 cpk 且保证 pk 的安全性。 free-code Https 原理解析 Https 知乎话题","link":"/2020/12/11/Https-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"}],"categories":[]}
{"pages":[],"posts":[{"title":"Java 基础笔记","text":"一、基础 JDK 和 JRE 有什么区别？ JDK（Java Development Kit）Java 开发环境，包括 JVM，编译器 javac 基础类库，和很多 Java 调试与分析的工具，比如 jconsole，jvisualvm 等。 JRE（Java Runtime Environment）Java 运行时环境。 == 和 equals 的区别是什么？ == 比较的是内存地址 equals 比较的是内容 两个对象的 hashCode() 相同，则 equals()也一定为 true，对吗？ 不对，两个对象的 hashCode 相同，equals() 不一定为 ture；相反，两个对象 equals() 相同，则 hashCode 一定相同。 final 在 java 中有什么作用？ final 作为 Java 中的关键字可以修饰三个地方：类、类属性、类方法。 修饰类：表示该类不能被继承； 修饰类变量：表示被修饰的变量只能一次赋值以后不能被修改； 修饰类方法：表示方法不能被重写。 ”不能被修改“ 对于不同的数据类型具有不同的含义： final 修饰基本数据类型时，这个数据的值在初始化后将不能被改变； final 修饰引用数据类型时，也就是修饰对象时，引用在初始化后将永远指向一个内存地址，不可以修改。但是该内存地址中保存的对象信息，是可以进行修改的。 Java 中的 Math.round(-1.5) 等于多少？ -1. Math 的 round 方法是四舍五入， 如果参数是负数，则往大的数加。如 Math.round(-1.5) = -1，如果是Math.round(1.5) 则结果为 2。 String 属于基础的数据类型吗？ 不是。基本数据类型：byte、short、char、int、lang、float、double、boolean。 Java 中操作字符串都有哪些类？它们之间有什么区别？ String StringBuffer StringBuilder 区别： 这个三个类都是以 char[] 的形式保存的字符串，但是 String 类型的字符串是不可改变[^1]的，对 String 类型的字符串做修改操作都是相当于重新创建对象，而对 StringBuffer 和 StringBuilder 进行增删改查操作都是对同一个对象的操作。 Stringbuffer 中的方法大部分都用了 synchronized 关键字修饰，所以 StringBuffer 是线程安全的。StringBuilder 中的方法则没有，线程不安全。但是 StringBuilder 因为没有使用 synchronized 关键字修饰，所以性能更高。在单线程的情况下我会选择使用 StringBuilder ，多线程环境下使用 StringBuffer。 如果申明的字符串几乎不做修改操作，最好直接使用 String, 因为不调用 new 关键字声明 String 类型的变量的话它不会在堆内存中创建对象，直接指向 String 的常量池，可以复用而且效率更高。 如何把一个 Int 类型转成字符串？把字符串转成 Int 呢？ 1String.valueOf(xxx); Integer.parseInt(xxx); 如何判断一个字符串是否以 “abc” 开头或者已 “abc” 结尾？ 使用 String.startsWith() 与 String.endWith() 方法判断字符串的以什么开头及已什么结尾。 startsWith() 与 endWith() 方法分别判断字符串是否以指定的内容开始或结束，返回值为 boolean 类型。 注：String.split() 方法可以做到[^2]，但是不推荐。 什么是抽象类？ 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 抽象类必须要有抽象方法吗？ 抽象类不一定有抽象方法[^4]，但是包含一个抽象方法的类一定是抽象类。 Java 中 final关键字有什么用？ 修饰类时 当用 final 修饰类时，表明这个类不能被继承。也就是说，如果一个类你永远不让它被继承，就可以用 final 修饰。final 类中的成员变量可以根据需要设置为 final，但是要注意 final 类中的所有成员方法都会被隐式的指定为 final 方法。 修饰方法时 使用 final 修饰的方法继承类无法修改。 修饰变量时 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化后便不能更改；如果是引用类型变量，则在对其初始化后便不能让其指向另一个对象。 Java 有哪些特性？ 封装 描述：隐藏对象的属性和实现细节，仅对外开放接口。 目的：增强安全与简化编程。 继承 描述：子类和父类之间的继承关系，子类可以获取到父类的属性和方法。 目的：代码复用。 多态 描述：事物在运行过程中存在不同的状态。 目的：增加代码的灵活度。 为什么要使用静态方法？ 静态方法的好处就是节省资源。 static 方法修饰的成员不再属于某个对象，而是属于它的类。只需要通过其类名就可以访问，不需要再消耗资源反复创建对象。在类第一次加载的时候，static 就已经存在内存中了，直到程序结束后，该内存才会被释放。 为什么静态方法不能调用非静态变量？ 静态方法不属于对象，属于类，是不需要实例化的，而非静态变量是属于对象的，需要先实例化。在一个类的静态成员中去访问非静态成员之所以会出错是因为类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会报错。 二、容器 Java 容器都有哪些？ list 特点：有序、允许重复 set 特点：无序、不可重复，只能有一个 null 存在 queue 特点：先进先出。新插入的元素放在队尾，队头存放着保存时间最长的元素。 map 特点：&lt;K, V&gt; 形式，可以保存”映射关系“。Value 可以重复，Key 不允许重复。 Collection 和 Collections 有什么区别？ Collection 是集合的接口，其继承类有 List 和 Set； Collections 是集合的工具类，定义了许多操作集合的静态方法（混排、翻转、替换、拷贝等），是帮助类。 哪些集合类是线程安全的？ Java 集合类中 Vector、HashTable、Properties 是线程安全的。ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap 等都是线程不安全[^3]的。 ArrayList 与 LinkedList 的区别？ 底层实现不同。 ArrayList 底层是 Object 数组，LinkedList 底层是双向链表。 对随机访问的支持不同。 ArrayList 由于底层是数组，数组天然支持根据数组的下标去访问里面的数据。 插入和删除的效率不同。 ArrayList 是由数组实现的，所以插入和删除元素受到元素位置的影响。而 LinkedList 采用的是链表来存储数据，添加和删除直接改变指向即可。适合删除，插入较多的场景。 对数据扩容的支持不同。 数组不支持动态扩容，像 ArrayList、Vector 和 Stack 使用的时候看似不用考虑容量问题，实际上它们底层进行了扩容。数组扩容代价比较大，需要开辟一个新数组将数据拷贝进去，效率也比较低，适合读数据较多的场景。 总结：如果是需要执行频繁的插入和删除操作的话，建议使用 LinkedList。如果是对数据进行频繁查找的话，建议使用 ArrayList。 HashMap 和 HashTable 有什么区别？ 同步性不同。 HashTable 的方法是同步的，HashMap 不同步。（HashTable 线程安全，HashMap 线程不安全） 继承的父类不同。 HashTable 继承自 Dictionary 类，HashMap 是继承自 AbstractMap 类。 对 null key 和 null value 的支持不同。 HashTable 不允许 null 值（Key 和 Value 都不可以），HashMap 允许使用 null 值（Key 和 value）都可以，这样的键只有一个，可以有一个或多个键所对应的值为 null。 遍历的方法不同。 HashTable 使用 Enumeration 遍历，HashMap 使用 Iterator 进行遍历。 初始化和扩容方式不同。 HashTable 默认初始大小为 11，之后每次扩容，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16，之后每次扩容，容量变为原来的 2 倍。 创建时，如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashTable 会尽量使用素数、奇数。而 HashMap 则是用 2 的幂作为哈希表的大小。 计算 hash 值的方法不同。 HashTable 直接使用 key 对象的 hashCode。hashCode 是 JDK 根据对象的地址进行计算得出来的 Int 值，然后用除留余数法来获取最终的位置。 HashMap 为了得到元素的位置，首先需要根据元素的 key 计算出一个 hash 值，然后再用这个 hash 值进行一系列计算来得到最终位置。 三、多线程 并行和并发有什么区别？ 并发：指应用能够交替执行不同的任务，类似于多线程的原理。 并行：指应用能够同时执行不同的任务。 创建线程有哪几种方式？ 继承 Thread 类，重写 run() 方法。创建 Thread 类的子类，使用子类调用 start() 方法启动多线程。 实现 Runnable 接口，重写 run() 方法。创建 Runnable 的实现，使用此实例创建 Thread 对象，调用 start() 方法。 实现 Callable 接口，重写 call() 方法。使用 FutureTask 对象作为 Thread 对象的 target 来创建线程。使用 FutureTask() 对象的 get() 方法来获得线程执行结果[^5]。 说一下 runnable 和 callable 有什么区别？ 实现 Callable 接口的任务线程能返回执行结果，而实现 Runnable 接口的任务线程不能返回结果。 Callable 接口的 call() 方法允许抛出异常；而 Runnable 接口的 run() 方法的异常只能在内部消化，不能继续往上抛。 六、Java Web session 和 cookie 有什么区别？ 存储位置不同。 session 存储在服务器端；cookie 存储在浏览器。 存储容量不同。 session 保存的数据大小取决于服务器的程序设计，理论上是可以做到不限；单个 cookie 保存的数据大小不超过 4kb，大多数浏览器限制一个站点最多 20 个 cookie。 存储方式不同。 session 能够存储任何类型的数据，包括且不限于 String、Integer、List、Map 等；cookie 只能保存 ASCII 字符串，并且需要通过编码方式存储为 Unicode 字符或者二进制数据。 隐私策略不同。 session 由于存在服务器端，安全性能高；cookie 存储在浏览器，可能被其它程序分析获取，安全性较低。 有效期上不同。 session 只要关闭窗口就会失效；cookie 可以通过设置，使 cookie 达到长期有效。 服务器压力不同。 session 是保管在服务端的，每个用户都会产生一个 session，对服务器的资源消耗较大；cookie 保管在浏览器中缓解了服务器存储信息的压力。 七、Redis Redis 可以存哪些数据结构？ 一共五种。 String Hash List Set Sorted Set Redis 的持久化机制是什么？ Redis 是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件夹来保证数据持久化。当 Redis 重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。 十、Spring/Spring MVC @ResponseBody 和 @RequestBody 有什么区别？ 作用域不同。 @ResponseBody 是作用在方法上，@RequestBody 是作用在形参列表上。 作用不同。 @ResponseBody 是把方法的返回结果直接写入 HTTP response body 中。 @ResquestBody 用于将前台发送过来的固定格式封装为对应的 JavaBean 对象。 @Autowired 与 @Resource 注解有什么不同？ 导的包不一样。 @Autowired 为 Spring 提供的注解，导入的包是org.springframework.beans.factory.annotation.Autowired。 @Resource 注解由 J2EE 提供，导入的包是 javax.annotation.Resource。 注入选择类型不一样。 @Autowired 默认按 byType 自动注入，@Resource 默认按 byName 自动注入。 十七、MySQL 如何从一张流水表中取出最新的 10 条数据？ 使用 group by 与 limit 关键字。 1SELECT * FROM `TABLE_NAME` group by CREATE_TIME limit 10 假如有一个学生登记表，里面有学生的姓名是重复的，如何把重复的姓名差出来？ 使用 group by 、having 与 count 函数。 1SELECT * FROM `TABLE_NAME` group by agent_code HAVING COUNT(agent_code ) &gt; 1 数据库三范式是什么？ 第一范式（1NF）： 每一列属性都是不可再分的属性值，确保每一列的原子性。 两列属性相似或相近的列，尽量合并为属性一样的列，确保不产生冗余数据。 第二范式（2NF）： 要求数据库表中的每个实例或者行必须可以被唯一区分，为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识，这个唯一属性列被称为主键。 第三范式（3NF）： 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。 十八、Mybatis MyBatis 中 #{} 和 ${} 有什么区别？ #{} 是以预编译的形式，将参数设置到 sql 语句中，以预编译的形式查询，可以防止 SQL 注入； ${} 是将参数拼接后再编译成SQL语句，不能防止 SQL 注入。 [^1]: 在 Java 平台类库中，包含许多不可变类，例如 String , 基本类型的包装类，BigInteger, BigDecimal 等等。综上所述，不可变类具有一些显著的通用特征：类本身是 final 修饰的；所有的域几乎都是私有 final 的；通常对其值的改变只是对其引用的改变，并不会真正去改变它本来的内存地址上的值。[^2]: 通过使用 split() 方法，给定一个正则，会根据该正则来将字符串切割，并且返回 String 类型的数组。[^3]: 线程不安全指的是：当多个线程访问同一个集合或者 Map 时，如果有多个线程同时在访问一个对象，则程序要需要手动保证该集合的同步性。 [^4]:Java 中的抽象方法就是以 abstract 修饰的方法，这种方法只声明返回值的数据类型、方法名称和所需的参数，没有方法体，也就是说抽象方法只需要声明而不需要实现。[^5]: FutureTask.get() 方法会阻塞主线程直到获取线程执行结果。","link":"/2020/11/30/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/11/29/hello-world/"}],"tags":[],"categories":[]}